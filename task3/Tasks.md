## Блок заданий №3

У нас была реализация сервера с двумя транспортами HTTP и Websocket, последняя ее версия тут
[`d-messenger`](https://github.com/HowProgrammingWorks/DDD/tree/master/JavaScript/d-messenger) а так же есть шаблон приложения на чистой ноде [NodeJS-Pure](https://github.com/metatech-university/NodeJS-Pure). Кроме прочего, они отличаются тем, что `d-messenger` умеет переключаться между режимами `http` и `ws`, а `NodeJS-Pure` умеет работать одновременно в обоих, он обслуживает подключения в зависимости от того, какой запрос они присылают. Разные транспорты отличаются тем, как данные принимаются и отправляются, используются ли HTTP заголовки, в частности куки и т.д., но разница эта не большая, в более сложной реализации протокола, как например наша библиотека [metacom](https://github.com/metarhia/metacom), учтено гораздо больше разных особенностей транспортов и реализовано больше функциональности. Давайте попробуем написать часть из нее, а если будут сложности, то всегда можно заглянуть в `metacom` за эталонной реализацией. Все нижеследующие задачи опциональны, Вы можете сами выбрать, что из них делать, а что нет, или отложить выполнение задачи на потом, когда она понадобится у вас в проекте.

1. Передача токенов сессий через HTTP заголовоки cookei (а не как мы это сделали сейчас - в теле пакета). Для этого у транспорта нужно реализовать набор методов для парсинга и формирования cookie, поддержки `HttpOnly`, срока действия. Можно защитить cookei криптографической контрольной суммой для быстрого определения их подделки.

2. Попробуйте расширить возможности сервера, обрабатывая не только RPC запросы по HTTP и WS, но принимая и запросы в стиле REST на базе HTTP протокола (хотя, для точности, следует заметить, что REST не имеет жесткой привязки к HTTP и его можно реализовывать почти на любом транспорте, включая даже UDP). Для этого задания ознакомьтесь с теоретическими статьями по REST подходу (желательно первоисточниками Роя Филдинга), по формированию URL, использованию HTTP методов, отсутствию состояния, кэшированию и т.д. Отнеситесь критически к тому, как реализован REST в разных проектах, в которых Вы брали участие и попробуйте найти концептуальные ошибки в реализации, которые не дадут получить выгоду от REST, как минимум в вопросах масштабируемости, производительности и надежности. А затем модифицируйте наш код так, чтобы использовать REST вместо RPC.

3. Реализуйте списки доступа к серверу по принципу `white list` или `block list` (`black list`), можно использовать новый класс `net.BlockList`, см. документацию https://nodejs.org/api/net.html#class-netblocklist для блокировки по маске.

4. Реализуйте поддержку Cross-Origin Resource Sharing (CORS) для нашего сервера. Базовую документацю по формированию HTTP заголовков можно найти на MDN: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

5. Давайте реализуем передачу файлов в нашем сервере, для этого нужно использовать файловые потоки `Readable` и `Writable` из `node:stream`. Можно как делать наследников, так и применять паттерн revealing constructor (открытый конструктор). Смотрите примеры в библиотеке [metacom](https://github.com/metarhia/metacom).

6. Реализуйте потоковое вещание для видео или звука по HTTP и/или WS, или передачу больших файлов с восстановлением при разрыве соединения. Можно реализовать такие возможностями: перемотка (указание начала и конца или только начального смещения), управление буферизацией, включая размер чанка, размер массива чанков, управление остановкой передачи с противоположной стороны, обработка ошибок передачи данных, восстановление и докачивание, параллельное скачивание через разные подключения нескольких частей одного потока, защита целостности контента при помощи контрольных сумм.
